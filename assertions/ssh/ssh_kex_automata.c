/*
 * This file is autogenerated by the Tesla CFA compiler
 * via: ../../cfa/splc -t tesla -s ssh_kex ssh_kex.spl
 */


#include <sys/types.h>

#ifdef _KERNEL
#include <sys/systm.h>
#else
#include <assert.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#endif

#include <tesla/tesla_state.h>
#include <tesla/tesla_util.h>

#include "ssh_kex_defs.h"

struct main {
  u_int state : 4;
} __attribute__((__packed__));

#define MAIN_PTR(tip) ((unsigned char *)((tip)->ti_state))
#define MAIN_STATE(tip,off) ((struct main *)(MAIN_PTR(tip)+(off)+1))
#define MAIN_NUM_STATES(tip) (MAIN_PTR(tip)[0])

void
ssh_kex_automata_init(struct tesla_instance *tip) {
  MAIN_NUM_STATES(tip) = 1;
  MAIN_STATE(tip,0)->state = 2; /* 1 */
}

int
ssh_kex_automata_prod(struct tesla_instance *tip, u_int event)
{
  unsigned char newstate[16];
  u_int i, curpos=1;
  struct main tmpstate;
  bzero(newstate, sizeof(newstate));
  switch (event) {
  case 0:  /* EVENT_FUNC_PROLOGUE_KEX_FINISH */
    for (i=0; i < MAIN_NUM_STATES(tip); i++) {
      switch (MAIN_STATE(tip,i)->state) {
      case 8:
        /* event 17 -> 11 */
        tmpstate.state = 4;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        /* event 17 -> 14 */
        tmpstate.state = 6;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        /* event 17 -> 8 */
        tmpstate.state = 9;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        break;
      default:
        break;
      }
    }
    newstate[0] = curpos-1;
    if (newstate[0] == 0)
      return 1; /* TESLA_ERROR */
    memcpy(MAIN_PTR(tip), &newstate, sizeof(newstate));
    return 0;

  case 1:  /* EVENT_FUNC_PROLOGUE_KEX_CLOSE */
    for (i=0; i < MAIN_NUM_STATES(tip); i++) {
      switch (MAIN_STATE(tip,i)->state) {
      case 9:
        /* event 8 -> 2 */
        tmpstate.state = 3;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        break;
      default:
        break;
      }
    }
    newstate[0] = curpos-1;
    if (newstate[0] == 0)
      return 1; /* TESLA_ERROR */
    memcpy(MAIN_PTR(tip), &newstate, sizeof(newstate));
    return 0;

  case 2:  /* EVENT_FUNC_PROLOGUE_KEX_INPUT_KEXINIT */
    for (i=0; i < MAIN_NUM_STATES(tip); i++) {
      switch (MAIN_STATE(tip,i)->state) {
      case 4:
        /* event 11 -> 12 */
        tmpstate.state = 5;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        break;
      case 7:
        /* event 15 -> 10 */
        tmpstate.state = 1;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        break;
      default:
        break;
      }
    }
    newstate[0] = curpos-1;
    if (newstate[0] == 0)
      return 1; /* TESLA_ERROR */
    memcpy(MAIN_PTR(tip), &newstate, sizeof(newstate));
    return 0;

  case 3:  /* EVENT_FUNC_PROLOGUE_KEX_SETUP */
    for (i=0; i < MAIN_NUM_STATES(tip); i++) {
      switch (MAIN_STATE(tip,i)->state) {
      case 2:
        /* event 1 -> 11 */
        tmpstate.state = 4;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        /* event 1 -> 14 */
        tmpstate.state = 6;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        /* event 1 -> 8 */
        tmpstate.state = 9;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        break;
      default:
        break;
      }
    }
    newstate[0] = curpos-1;
    if (newstate[0] == 0)
      return 1; /* TESLA_ERROR */
    memcpy(MAIN_PTR(tip), &newstate, sizeof(newstate));
    return 0;

  case 4:  /* EVENT_FUNC_PROLOGUE_KEX_SEND_KEXINIT */
    for (i=0; i < MAIN_NUM_STATES(tip); i++) {
      switch (MAIN_STATE(tip,i)->state) {
      case 5:
        /* event 12 -> 10 */
        tmpstate.state = 1;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        break;
      case 6:
        /* event 14 -> 15 */
        tmpstate.state = 7;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        break;
      default:
        break;
      }
    }
    newstate[0] = curpos-1;
    if (newstate[0] == 0)
      return 1; /* TESLA_ERROR */
    memcpy(MAIN_PTR(tip), &newstate, sizeof(newstate));
    return 0;

  case 5:  /* EVENT_FUNC_PROLOGUE_KEX_CHOOSE_CONF */
    for (i=0; i < MAIN_NUM_STATES(tip); i++) {
      switch (MAIN_STATE(tip,i)->state) {
      case 1:
        /* event 10 -> 17 */
        tmpstate.state = 8;
        memcpy(&(newstate[curpos]), &tmpstate, 1);
        curpos++;
        break;
      default:
        break;
      }
    }
    newstate[0] = curpos-1;
    if (newstate[0] == 0)
      return 1; /* TESLA_ERROR */
    memcpy(MAIN_PTR(tip), &newstate, sizeof(newstate));
    return 0;

  default:
    return 1; /* TESLA_UNKNOWN_EVENT */
  }
}

