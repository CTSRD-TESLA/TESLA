/* vim: set syntax=proto: */
/**
 * We can't include comments directly in a .tesla file because it's a
 * text-based serialisation format for protocol buffers. Instead, let's abuse
 * the C preprocessor a little bit:
 *
 * RUN: cpp -P -DTESLA %s %cpp_out %t.tesla
 * RUN: tesla graph %t.tesla -o %t.dot
 * RUN: FileCheck -input-file=%t.dot %s
 */

#ifdef TESLA
automaton {
  /*
   * CHECK: digraph automaton_{{[0-9]+}}
   *
   * TODO: if/when we move to LLVM 3.4, use the CHECK-DAG prefix and distribute
   *       these state checks to be closer to their relevant transitions:
   *
   * CHECK: 0 [ label = "state 0\n([[ANY:&#[0-9]+;]],[[ANY:&#[0-9]+;]])" ];
   * CHECK: [[INIT:[0-9]+]] [ label = "state [[INIT]]\n([[ANY]],[[ANY]])" ];
   * CHECK: [[CHECK2:[0-9]+]] [ label = "state [[CHECK2]]\n(o,[[ANY]])" ];
   * CHECK: [[CHECK23:[0-9]+]] [ label = "state [[CHECK23]]\n(o,op)" ];
   * CHECK: [[ASSERT:[0-9]+]] [ label = "state [[ASSERT]]\n(o,op)" ];
   */
  identifier {
    location {
      filename: "example.c"
      line: 314
      counter: 42
    }
  }
  context: ThreadLocal
  expression {
    type: SEQUENCE
    sequence {
      /*
       * CHECK: label = "example_syscall([[ANY]],[[ANY]],[[ANY]])
       * CHECK: 0 -> [[INIT]];
       */
      expression {
        type: FUNCTION
        function {
          function {
            name: "example_syscall"
          }
          direction: Entry
          context: Callee
          argument {
            type: Any
            name: "cred"
          }
          argument {
            type: Any
            name: "index"
          }
          argument {
            type: Any
            name: "op"
          }
        }
      }
      /*
       * CHECK: label = "security_check([[ANY]],o,[[ANY]])
       * CHECK: [[INIT]] -> [[CHECK2]];
       */
      expression {
        type: FUNCTION
        function {
          function {
            name: "security_check"
          }
          direction: Exit
          context: Callee
          argument {
            type: Any
          }
          argument {
            type: Variable
            index: 0
            name: "o"
          }
          argument {
            type: Any
          }
          expectedReturnValue {
            type: Constant
            name: "since"
            value: 0
          }
        }
      }
      /*
       * After that transition, we know about one referenced variable:
       *
       * CHECK: label = "security_check([[ANY]],o,op)
       * CHECK: [[CHECK2]] -> [[CHECK23]];
       */
      expression {
        type: FUNCTION
        function {
          function {
            name: "security_check"
          }
          direction: Exit
          context: Callee
          argument {
            type: Any
          }
          argument {
            type: Variable
            index: 0
            name: "o"
          }
          argument {
            type: Variable
            index: 1
            name: "op"
          }
          expectedReturnValue {
            type: Constant
            name: "since"
            value: 0
          }
        }
      }
      /*
       * CHECK: label = "{{.*}}assertion{{.*}}"
       * CHECK: [[CHECK23]] -> [[ASSERT]];
       */
      expression {
        type: ASSERTION_SITE
        assertSite {
          location {
            filename: "example.c"
            line: 46
            counter: 0
          }
        }
      }
    }
  }
  argument {
    type: Variable
    index: 0
    name: "o"
  }
  argument {
    type: Variable
    index: 1
    name: "op"
  }
  /*
   * CHECK: label = "example.c:314#42"
   */
}
root {
  identifier {
    location {
      filename: "example.c"
      line: 314
      counter: 42
    }
  }
}
root {
  identifier {
    location {
      filename: "example.c"
      line: 46
      counter: 0
    }
  }
}
#endif

