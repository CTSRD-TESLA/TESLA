${HEADER}

<p>
This page provides a high-level overview of the TESLA primitives made available
to programmers wishing to add temporal assertions to their code.
Programmers wishing to extend TESLA itself should consult
<a href="api">the API documentation</a>.
</p>

<p>
Most code examples on this page come from
<a href="https://github.com/CTSRD-TESLA/TESLA/demos/smoketest/example.c">demos/smoketest/example.c</a>
in the TESLA repository.
</p>

<a name="headers"></a>
<h2>Header files</h2>

<p>
TESLA provides programmers with two header file options:
<a href="api/tesla_8h.xhtml">tesla.h</a>, which defines TESLA primitives
prefixed by __tesla, and <a href="api/tesla-macros_8h.xhtml">tesla-macros.h</a>,
which provides examples of macros that are more
programmer-friendly but could cause namespace collisions.
We recommend that you start with the example
<a href="api/tesla-macros_8h.xhtml">tesla-macros.h</a> and
modify it as necessary to avoid namespace collisions with your code.
</p>


<a name="inputs"></a>
<h2>Assertions and automata</h2>

<p>
TESLA accepts two types of input: inline assertions and explicit automata.
Both inputs describe the expected temporal behaviour of software; TESLA
checks actual run-time behaviour against such descriptions.
</p>


<a name="assertions"></a>
<h3>Inline assertions</h3>

<p>
Inline assertions are typically declared with the TESLA_GLOBAL or
TESLA_PERTHREAD macros, or else the per-thread convenience wrapper
TESLA_WITHIN.
These macros wrap the __tesla_inline_assertion function, which expects
several arguments:
</p>

<ul>
  <li>
    an assertion location:
    <ul>
      <li>filename, line number and counter</li>
      <li>provided implicitly by the above macros</li>
    </ul>
  </li>
  <li>
    a storage and synchronisation context
    <ul>
      <li>global or per-thread</li>
      <li>provided implicitly by the above macros</li>
    </ul>
  </li>
  <li>
    context bounds, at which all instances of an automaton should be
    initialised and cleaned up
    <ul>
      <li>
        bounds must be <a href="#concrete">concrete events</a>
        rather than <a href="#abstract">abstract expressions</a>
      </li>
      <li>
        TESLA_GLOBAL and TESLA_PERTHREAD expect explicit <em>start</em> and
        <em>end</em> bounds
      </li>
      <li>
        TESLA_WITHIN expects a function whose entry and exit are the
        start and end bounds
      </li>
    </ul>
  </li>
  <li>a <a href="#expressions">TESLA expression</a></li>
</ul>

<a name="automata"></a>
<h3>Explicit automata</h3>

<p>
Programmers can also describe automata directly; this is useful for explicit
state machines such the TCP state machine.
</p>

<p>
Automata are declared and defined like C functions.
The expected signature is:
</p>

<div class="code"><span class="comment">/* Declarations */</span>
<span class="keyword">automaton</span>(assertion_name, <span class="keyword">struct</span> struct_type *);
<span class="keyword">automaton</span>(some_other_automaton, <span class="keyword">struct</span> struct_type *);

<span class="comment">/* Definition */</span>
<span class="keyword">automaton</span>(assertion_name, <span class="keyword">struct</span> struct_type *sp)
{
  <span class="comment">/*
   * a sequence of TESLA expressions
   * that reference the 'sp' pointer,
   * for instance:
   */</span>
  some_other_automaton(sp);

  <span class="control">done</span>;
}
</div>

TESLA_STRUCT_AUTOMATON(struct tcpcb *tp, my_tcpcb_assertion, __tesla_global,
                       called(tcp_init, tp),
                       returned(tcp_free, tp));


<p>
The single variable referenced by the automaton must be declared as a formal
parameter.
All sub-automata (e.g. some_other_automaton() in the above example) must
operate on the same type.
</p>


<a name="expressions"></a>
<h2>TESLA expressions</h2>

<p>
There are six kinds of TESLA expressions, three abstract expressions and
three concrete events:
</p>

<ul>
  <li>
    abstract
    <ul>
      <li><a href="#boolean_expr">boolean expression</a></li>
      <li><a href="#sequence">sequence</a></li>
      <li><a href="#sub_automaton">sub-automaton</a></li>
    </ul>
  </li>
  <li>
    concrete
    <ul>
      <li><a href="#fn_invoke">function invocation / return</a></li>
      <li><a href="#field_assign">structure field assignment</a></li>
      <li><a href="#now">"now"</a></li>
    </ul>
  </li>
</ul>

<a name="abstract"></a>
<h3>Abstract expressions</h3>

<a name="boolean_expr"></a>
<h4>Boolean expression</h4>
<p>
TESLA expressions may be combined with boolean operators.
Currently, the only supported operator is OR ('<span class="code">||</span>').
instead of <span class="code">a AND b</span>, programmers can write
<span class="code">a</span> and <span class="code">b</span> as separate
assertions.
</p>

<a name="sequence"></a>
<h4>Sequence</h4>
<p>
A sequence of events can be specified with the
<span class="control">TSEQUENCE</span> macro, whose
parameters are themselves TESLA expressions.
For instance:
</p>

<div class="code"><span class="control">TSEQUENCE</span>(
  foo(x) == 0,
  bar(y) || baz(z)
)</div>

<a name="sub_automaton"></a>
<h4>Sub-automaton</h4>
<p>
Automata can "include" <a href="#automata">explicitly-declared automata</a>
by "calling" them:
</p>

<div class="code"><span class="keyword">automaton</span>(active_close, <span class="keyword">struct</span> tcpcb*);
<span class="keyword">automaton</span>(established, <span class="keyword">struct</span> tcpcb*);

<span class="keyword">automaton</span>(my_tcpcb_assertion, <span class="keyword">struct</span> tcpcb *tp)
{
	tp-&gt;t_state = TCPS_SYN_RECEIVED,
	established(tp) || active_close(tp)
}
</div>


<a name="concrete"></a>
<h3>Concrete expressions</h3>

<a name="fn_invoke"></a>
<h4>Function invocation</h4>
<p>
TODO
</p>

<a name="field_assign"></a>
<h4>Structure field assignment</h4>
<p>
TODO
</p>

<a name="now"></a>
<h4>"now"</h4>
<p>
TODO
</p>


${FOOTER}
